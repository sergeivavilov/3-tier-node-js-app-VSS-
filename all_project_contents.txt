Directory Structure:
.
├── README.md
├── all_project_contents.txt
├── api
│   ├── Dockerfile
│   ├── README.md
│   ├── app.js
│   ├── bin
│   │   └── www
│   ├── package-lock.json
│   └── package.json
├── compose.yaml
├── ingress.yaml
├── node-js-app
│   ├── Chart.yaml
│   ├── back.yaml
│   ├── database.yaml
│   ├── front.yaml
│   ├── ingress.yaml
│   ├── templates
│   │   ├── NOTES.txt
│   │   ├── _helpers.tpl
│   │   ├── deployment.yaml
│   │   ├── ingress.yaml
│   │   ├── service.yaml
│   │   └── tests
│   │       └── test-connection.yaml
│   ├── values
│   │   ├── backend.yaml
│   │   └── frontend.yaml
│   └── values.yaml
└── web
    ├── Dockerfile
    ├── README.md
    ├── app.js
    ├── bin
    │   └── www
    ├── package-lock.json
    ├── package.json
    ├── public
    │   └── stylesheets
    │       └── style.css
    ├── routes
    │   └── index.js
    └── views
        ├── error.jade
        ├── index.jade
        └── layout.jade

13 directories, 35 files

./node-js-app/ingress.yaml
Contents of ./node-js-app/ingress.yaml:
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ingress-for-front
  namespace: sample-app
spec:
  rules:
  - host: "app.easydevops.click"
    http:
      paths:
      - pathType: Prefix
        path: "/"
        backend:
          service:
            name: front-svc
            port:
              number: 80
./node-js-app/Chart.yaml
Contents of ./node-js-app/Chart.yaml:
apiVersion: v2
name: node-js-app
description: A Helm chart for Kubernetes

# A chart can be either an 'application' or a 'library' chart.
#
# Application charts are a collection of templates that can be packaged into versioned archives
# to be deployed.
#
# Library charts provide useful utilities or functions for the chart developer. They're included as
# a dependency of application charts to inject those utilities and functions into the rendering
# pipeline. Library charts do not define any templates and therefore cannot be deployed.
type: application

# This is the chart version. This version number should be incremented each time you make changes
# to the chart and its templates, including the app version.
# Versions are expected to follow Semantic Versioning (https://semver.org/)
version: 0.1.0

# This is the version number of the application being deployed. This version number should be
# incremented each time you make changes to the application. Versions are not expected to
# follow Semantic Versioning. They should reflect the version the application is using.
# It is recommended to use it with quotes.
appVersion: "1.16.0"

./node-js-app/values/frontend.yaml
Contents of ./node-js-app/values/frontend.yaml:

# values for deployments
replicaCount: 1
applicationName: node-js-front
image:
  repository: 730335359268.dkr.ecr.us-east-1.amazonaws.com/nodejsapp
  tag: 0.1
  pullPolicy: IfNotPresent
port: 80

# values for service
service:
  type: ClusterIP
  port: 80

# values for ingress
ingress:
  enabled: true
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local
./node-js-app/values/backend.yaml
Contents of ./node-js-app/values/backend.yaml:

# values for deployments
replicaCount: 1
applicationName: backend-api
image:
  repository: 730335359268.dkr.ecr.us-east-1.amazonaws.com/apirepo
  tag: 0.1
  pullPolicy: IfNotPresent
port: 80

# values for service
service:
  type: ClusterIP
  port: 80

# # values for ingress
# ingress:
#   enabled: false
#   className: ""
#   annotations: {}
#     # kubernetes.io/ingress.class: nginx
#     # kubernetes.io/tls-acme: "true"
#   hosts:
#     - host: chart-example.local
#       paths:
#         - path: /
#           pathType: ImplementationSpecific
#   tls: []
./node-js-app/front.yaml
Contents of ./node-js-app/front.yaml:
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: sample-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - image: 730335359268.dkr.ecr.us-east-1.amazonaws.com/nodejsapp:0.1
        name: frontend
        ports:
          - containerPort: 80

---


apiVersion: v1
kind: Service
metadata:
  name: front-svc
  namespace: sample-app
spec:
  selector:
    app: frontend
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
./node-js-app/database.yaml
Contents of ./node-js-app/database.yaml:
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres-deployment
  namespace: sample-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
        - name: postgres
          image: postgres:16
          env:
            - name: POSTGRES_USER
              value: postgres
            - name: POSTGRES_PASSWORD
              value: dbcrackers
            - name: POSTGRES_DB
              value: homeworkdb
          ports:
            - containerPort: 5432
---
apiVersion: v1
kind: Service
metadata:
  name: postgres-svc
  namespace: sample-app
spec:
  selector:
    app: postgres
  ports:
    - protocol: TCP
      port: 5432
      targetPort: 5432
./node-js-app/templates/deployment.yaml
Contents of ./node-js-app/templates/deployment.yaml:
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "node-js-app.fullname" . }}
  labels:
    {{- include "node-js-app.labels" . | nindent 4 }}
spec:
  selector:
    matchLabels:
      {{- include "node-js-app.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      labels:
        {{- include "node-js-app.labels" . | nindent 8 }}
    spec:
      containers:
        - name: {{ .Chart.Name }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - name: http
              containerPort: {{ .Values.service.port }}
              protocol: TCP
          livenessProbe:
            {{- toYaml .Values.livenessProbe | nindent 12 }}
          readinessProbe:
            {{- toYaml .Values.readinessProbe | nindent 12 }}
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
          {{- with .Values.volumeMounts }}
          volumeMounts:
            {{- toYaml . | nindent 12 }}
          {{- end }}
      {{- with .Values.volumes }}
      volumes:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}

./node-js-app/templates/ingress.yaml
Contents of ./node-js-app/templates/ingress.yaml:
{{- if .Values.ingress.enabled -}}
{{- $fullName := include "node-js-app.fullname" . -}}
{{- $svcPort := .Values.service.port -}}
{{- if and .Values.ingress.className (not (semverCompare ">=1.18-0" .Capabilities.KubeVersion.GitVersion)) }}
  {{- if not (hasKey .Values.ingress.annotations "kubernetes.io/ingress.class") }}
  {{- $_ := set .Values.ingress.annotations "kubernetes.io/ingress.class" .Values.ingress.className}}
  {{- end }}
{{- end }}
{{- if semverCompare ">=1.19-0" .Capabilities.KubeVersion.GitVersion -}}
apiVersion: networking.k8s.io/v1
{{- else if semverCompare ">=1.14-0" .Capabilities.KubeVersion.GitVersion -}}
apiVersion: networking.k8s.io/v1beta1
{{- else -}}
apiVersion: extensions/v1beta1
{{- end }}
kind: Ingress
metadata:
  name: {{ $fullName }}
  labels:
    {{- include "node-js-app.labels" . | nindent 4 }}
  {{- with .Values.ingress.annotations }}
  annotations:
    {{- toYaml . | nindent 4 }}
  {{- end }}
spec:
  {{- if and .Values.ingress.className (semverCompare ">=1.18-0" .Capabilities.KubeVersion.GitVersion) }}
  ingressClassName: {{ .Values.ingress.className }}
  {{- end }}
  {{- if .Values.ingress.tls }}
  tls:
    {{- range .Values.ingress.tls }}
    - hosts:
        {{- range .hosts }}
        - {{ . | quote }}
        {{- end }}
      secretName: {{ .secretName }}
    {{- end }}
  {{- end }}
  rules:
    {{- range .Values.ingress.hosts }}
    - host: {{ .host | quote }}
      http:
        paths:
          {{- range .paths }}
          - path: {{ .path }}
            {{- if and .pathType (semverCompare ">=1.18-0" $.Capabilities.KubeVersion.GitVersion) }}
            pathType: {{ .pathType }}
            {{- end }}
            backend:
              {{- if semverCompare ">=1.19-0" $.Capabilities.KubeVersion.GitVersion }}
              service:
                name: {{ $fullName }}
                port:
                  number: {{ $svcPort }}
              {{- else }}
              serviceName: {{ $fullName }}
              servicePort: {{ $svcPort }}
              {{- end }}
          {{- end }}
    {{- end }}
{{- end }}

./node-js-app/templates/tests/test-connection.yaml
Contents of ./node-js-app/templates/tests/test-connection.yaml:
apiVersion: v1
kind: Pod
metadata:
  name: "{{ include "node-js-app.fullname" . }}-test-connection"
  labels:
    {{- include "node-js-app.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": test
spec:
  containers:
    - name: wget
      image: busybox
      command: ['wget']
      args: ['{{ include "node-js-app.fullname" . }}:{{ .Values.service.port }}']
  restartPolicy: Never

./node-js-app/templates/service.yaml
Contents of ./node-js-app/templates/service.yaml:
apiVersion: v1
kind: Service
metadata:
  name: {{ include "node-js-app.fullname" . }}
  labels:
    {{- include "node-js-app.labels" . | nindent 4 }}
spec:
  type: {{ .Values.service.type }}
  ports:
    - port: {{ .Values.service.port }}
      targetPort: http
      protocol: TCP
      name: http
  selector:
    {{- include "node-js-app.selectorLabels" . | nindent 4 }}

./node-js-app/back.yaml
Contents of ./node-js-app/back.yaml:
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-deploy
  namespace: sample-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend-api
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
  template:
    metadata:
      labels:
        app: backend-api
    spec:
      containers:
      - image: 730335359268.dkr.ecr.us-east-1.amazonaws.com/apirepo:0.1
        name: backend-api
        ports:
          - containerPort: 3000


---

 
apiVersion: v1
kind: Service
metadata:
  name: backend-svc
  namespace: sample-app
spec:
  selector:
    app: backend-api
  ports:
    - protocol: TCP
      port: 3000
      targetPort: 3000
./node-js-app/values.yaml
Contents of ./node-js-app/values.yaml:
# # Default values for node-js-app.
# # This is a YAML-formatted file.
# # Declare variables to be passed into your templates.

# replicaCount: 1

# image:
#   repository: nginx
#   pullPolicy: IfNotPresent
#   # Overrides the image tag whose default is the chart appVersion.
#   tag: ""

# imagePullSecrets: []
# nameOverride: ""
# fullnameOverride: ""

# serviceAccount:
#   # Specifies whether a service account should be created
#   create: true
#   # Automatically mount a ServiceAccount's API credentials?
#   automount: true
#   # Annotations to add to the service account
#   annotations: {}
#   # The name of the service account to use.
#   # If not set and create is true, a name is generated using the fullname template
#   name: ""

# podAnnotations: {}
# podLabels: {}

# podSecurityContext: {}
#   # fsGroup: 2000

# securityContext: {}
#   # capabilities:
#   #   drop:
#   #   - ALL
#   # readOnlyRootFilesystem: true
#   # runAsNonRoot: true
#   # runAsUser: 1000

# service:
#   type: ClusterIP
#   port: 80

# ingress:
#   enabled: false
#   className: ""
#   annotations: {}
#     # kubernetes.io/ingress.class: nginx
#     # kubernetes.io/tls-acme: "true"
#   hosts:
#     - host: chart-example.local
#       paths:
#         - path: /
#           pathType: ImplementationSpecific
#   tls: []
#   #  - secretName: chart-example-tls
#   #    hosts:
#   #      - chart-example.local

# resources: {}
#   # We usually recommend not to specify default resources and to leave this as a conscious
#   # choice for the user. This also increases chances charts run on environments with little
#   # resources, such as Minikube. If you do want to specify resources, uncomment the following
#   # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
#   # limits:
#   #   cpu: 100m
#   #   memory: 128Mi
#   # requests:
#   #   cpu: 100m
#   #   memory: 128Mi

# livenessProbe:
#   httpGet:
#     path: /
#     port: http
# readinessProbe:
#   httpGet:
#     path: /
#     port: http

# autoscaling:
#   enabled: false
#   minReplicas: 1
#   maxReplicas: 100
#   targetCPUUtilizationPercentage: 80
#   # targetMemoryUtilizationPercentage: 80

# # Additional volumes on the output Deployment definition.
# volumes: []
# # - name: foo
# #   secret:
# #     secretName: mysecret
# #     optional: false

# # Additional volumeMounts on the output Deployment definition.
# volumeMounts: []
# # - name: foo
# #   mountPath: "/etc/foo"
# #   readOnly: true

# nodeSelector: {}

# tolerations: []

# affinity: {}

./ingress.yaml
Contents of ./ingress.yaml:
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: nginx-ingress-clusterrole
rules:
- apiGroups:
    - ""
    - "extensions"
  resources:
    - "configmaps"
    - "endpoints"
    - "events"
    - "ingresses"
    - "ingresses/status"
    - "services"
  verbs:
    - "create"
    - "get"
    - "list"
    - "update"
    - "watch"
    - "delete"

---

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: nginx-ingress-clusterrolebinding
subjects:
- kind: ServiceAccount
  name: default
  namespace: ingress-nginx  # Replace with your desired namespace
roleRef:
  kind: ClusterRole
  name: nginx-ingress-clusterrole  # Name of the ClusterRole created earlier
  apiGroup: rbac.authorization.k8s.io

./web/README.md
Contents of ./web/README.md:
# Devops Web App

## install the node packages for the web tier

```
npm 8 or higher
node 16 or higher
```


```sh
  npm install
```

## start the app

```sh
  npm start
```

## NOTE this app uses two env variables

- PORT: optional variable to specify the listening PORT. Default is 3000
- API_HOST: the full url to call the API app (syntax: `http://BACKEND_HOSTNAME:BACKEND_PORT`)

These two variables need to be set

## Expected UI page all components are working: Frontend => Backend => DB

![Frontend-expected-UI](https://github.com/312-bc/3-tier-node-js-app-23C/assets/43100287/a1d2dc62-1f34-4c75-8688-77269b4f381e)

./web/public/stylesheets/style.css
Contents of ./web/public/stylesheets/style.css:
body {
  padding: 50px;
  font: 14px "Lucida Grande", Helvetica, Arial, sans-serif;
}

a {
  color: #00B7FF;
}

./web/package.json
Contents of ./web/package.json:
{
  "name": "web",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "start": "node ./bin/www"
  },
  "dependencies": {
    "body-parser": "~1.13.2",
    "cookie-parser": "~1.3.5",
    "debug": "~2.6.9",
    "express": "~4.13.1",
    "jade": "~1.11.0",
    "morgan": "~1.6.1",
    "redis": "^1.0.0",
    "redis-url": "^1.2.1",
    "serve-favicon": "~2.3.0",
    "request": "2.72.0"
  }
}

./web/routes/index.js
Contents of ./web/routes/index.js:
var express = require('express');
var router = express.Router();
var request = require('request');

var ipAddress = process.env.IP_ADDRESS || '10.7.110.213';  // Default IP address if not set in environment
var api_url = 'http://' + ipAddress + '/api/status';
// var api_url = process.env.VARIABLE + '/api/status';

/* GET home page. */
router.get('/', function (req, res, next) {
    request({
        method: 'GET',
        url: api_url,
        json: true
    },
        function (error, response, body) {
            if (error || response.statusCode !== 200) {
                return res.status(500).send('error running request to ' + api_url);
            } else {
                res.render('index', {
                    title: 'Frontend - Hi upcoming DevOps Engineers, how is hands-on?',
                    request_uuid: body.request_uuid,
                    time: body.time
                });
            }
        }
    );
});

module.exports = router;
./web/app.js
Contents of ./web/app.js:
var express = require('express');
var path = require('path');
var favicon = require('serve-favicon');
var logger = require('morgan');
var cookieParser = require('cookie-parser');
var bodyParser = require('body-parser');

var routes = require('./routes/index');

var app = express();

// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'jade');

// uncomment after placing your favicon in /public
//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));
app.use(logger('dev'));
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: false }));
app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));

app.use('/', routes);

// catch 404 and forward to error handler
app.use(function(req, res, next) {
  var err = new Error('Not Found');
  err.status = 404;
  next(err);
});

// error handlers

// development error handler
// will print stacktrace
if (app.get('env') === 'development') {
  app.use(function(err, req, res, next) {
    res.status(err.status || 500);
    res.render({
      message: err.message,
      error: err
    });
  });
}

// production error handler
// no stacktraces leaked to user
app.use(function(err, req, res, next) {
  res.status(err.status || 500);
  res.render({
    message: err.message,
    error: {}
  });
});


module.exports = app;

./README.md
Contents of ./README.md:
[![Reviews App CI/CD Pipeline](https://github.com/sergeivavilov/3-tier-node-js-app-vss/actions/workflows/app-pipeline.yaml/badge.svg)](https://github.com/sergeivavilov/3-tier-node-js-app-vss/actions/workflows/app-pipeline.yaml)



[![Reviews App CI/CD Pipeline](https://github.com/sergeivavilov/3-tier-node-js-app-vss/actions/workflows/app-pipeline.yaml/badge.svg)](https://github.com/sergeivavilov/3-tier-node-js-app-vss/actions/workflows/app-pipeline.yaml)



[![Reviews App CI/CD Pipeline](https://github.com/sergeivavilov/3-tier-node-js-app-vss/actions/workflows/app-pipeline.yaml/badge.svg)](https://github.com/sergeivavilov/3-tier-node-js-app-vss/actions/workflows/app-pipeline.yaml)



================================================================================================================================================================
{
  echo "Directory Structure:";
  tree;
  echo "";

  # Loop through each text-based file including YAML and JSON files and print its contents
  find . -type f \( -name "*.md" -o -name "*.py" -o -name "*.sql" -o -name "*.js" -o -name "*.html" -o -name "*.css" -o -name "*.yaml" -o -name "*.json" \) ! -name "package-lock.json" -print -exec echo "Contents of {}:" \; -exec cat {} \; -exec echo "" \;

  # Explicitly add specific files like the GitHub Actions workflow
  echo "Contents of .github/workflows/app-pipeline.yaml:"
  cat 3-tier-node-js-app-vss/.github/workflows/app-pipeline.yaml
  echo "";
} > all_project_contents.txt



================================================================================================================================================================


# 3-Tier Application: Product Review System

## Overview
This repository contains a 3-tier web application, the Product Review System, where users can add products and leave reviews. The 3-tier architecture comprises a frontend, backend, and a database. The application is designed to run on AWS infrastructure with high availability and scalability in mind.

- The Frontend application provides a user interface built with HTML, CSS, and JavaScript, served by an Nginx server. 

- The Backend is a RESTful API built with Python and Flask, which processes requests, performs operations, and interfaces with a MySQL database.

- The MySQL Database stores product and review data.

For more details about each component, refer to the README files in their respective directories:

- [Frontend](./frontend/README.md)
- [Backend](./api-backend/README.md)

## Important Note
Since our frontend just hosts static webpages, it relies on client-side browser processing with Javascript. Therefore requests to the backend come from the user directly (browsers calls the APIs to backend), which means that backend DNS name also needs to be publicly accessible.

Flow of the request is `Client => Frontend => Client => Backend => Database`


## Diagrams

**Software Design Overview**
![Software Design Overview](random/mini-project-software-design.png)

**Infrastructure Design Overview**
![Infrastructure Design Overview](random/mini-project-infra.png)



## Helpful Resources on Learning to work with Git:

Naming Conventions:

- Best practices for file and branch naming: **https://namingconvention.org/git/**

Git/GitHub Fundamentals:

- Official Git documentation: **https://git-scm.com/doc**

Pull Requests (PRs):
- GitHub Pull Request documentation: **https://docs.github.com/en/pull-requests**


./.github/workflows/kubernetes-deploy.yaml
Contents of ./.github/workflows/kubernetes-deploy.yaml:

name: NodeJs Deployment Workflow

on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  push:
    branches: ["*"]

permissions:
  id-token: write # This is required for requesting the JWT
  contents: read  # This is required for actions/checkout

jobs:
  deploy:
    runs-on: ubuntu-latest
    # Select environment based on branch pushed
    environment: ${{ (github.ref == 'refs/heads/main' && 'dev') || (github.ref == 'refs/heads/prod' && 'production') }}

    steps:
      - name: AWS Loggin
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.IAM_ROLE }}
          # role-session-name: kubernetesbot 
          aws-region: "us-east-1"

      - name: clone repo 
        uses: actions/checkout@v4

      - name: Login to ECR
        id: login-to-ecr
        uses: aws-actions/amazon-ecr-login@v2

# commment out to speed up jobs and to not replicate images over and over again
      - name: Build, tag, and push frontend docker image to Amazon ECR
        env:
          REGISTRY: ${{ steps.login-to-ecr.outputs.registry }}
          REPOSITORY: nodejsapp
          IMAGE_TAG: 0.1
        working-directory: ./web
        run: |
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG .
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
      
      # - name: Build, tag, and push Backend docker image to Amazon ECR
      #   env:
      #     REGISTRY: ${{ steps.login-to-ecr.outputs.registry }}
      #     REPOSITORY: apirepo
      #     IMAGE_TAG: 0.1
      #   working-directory: ./api
      #   run: |
      #     docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG .
      #     docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG

# login to EKS
      - name: Login to EKS
        run: aws eks update-kubeconfig --region us-east-1 --name project-x-dev

# creating namespace
      - name: Create namespace
        run: kubectl create namespace sample-app || true


# Install NGINX ingress controller. repo add nad update lines in testing
      - name: Install NGINX Ingress Controller
        run: kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.10.1/deploy/static/provider/cloud/deploy.yaml

# deploy frontend by YAML file
      - name: deploy frontend and service for it
        run: kubectl apply -f node-js-app/front.yaml

# deploy backend by YAML file
      - name: deploy backend and service for it
        run: kubectl apply -f node-js-app/back.yaml

# deploy database by YAML file
      - name: deploy database and service for it
        run: kubectl apply -f node-js-app/database.yaml

# deploy services and ingress by YAML file
      - name: ingress rules
        run: kubectl apply -f node-js-app/ingress.yaml

# deploy frontend      
      # - name: Deploy frontend
      #   run: helm upgrade --install node-js-app ./node-js-app/ --values ./node-js-app/values/frontend.yaml --namespace sample-app

# run backend pod   
      # - name: Deploy backend
      #   run: |
      #     helm upgrade --install node-js-api ./node-js-app/ --values ./node-js-app/values/backend.yaml --namespace sample-app

# apply service file through kubectl apply 


# apply ingress rules file through kubectl apply

# see what happens
      
./compose.yaml
Contents of ./compose.yaml:
services:
  webcontainer:
    build: web/
    ports:
      - "80:80"
    networks:
      - appnetwork
    environment:
      API_HOST: "http://apicontainer:3000"
  apicontainer:
    build: api/
    networks:
      - appnetwork
    environment:
      DB: "postgres://pgadmin:crackers@dbcontainer/sampledb"
  dbcontainer:
    image: "postgres:16"
    environment:
      POSTGRES_PASSWORD: "crackers"
      POSTGRES_USER: "pgadmin"
      POSTGRES_DB: "sampledb"
    networks:
      - appnetwork
networks:
  appnetwork:


./api/README.md
Contents of ./api/README.md:
# Devops API App

# System Requirements

```
npm 8 or higher
node 16 or higher
```

## install the node packages for the api tier

```sh
→ npm install
```

## start the app

```sh
→ npm start
```

## NOTE this app uses two env variables

- PORT: optional variable to specify the listening PORT. Default is 3000
- DB: the postgresql url (also called as DB Connection string) to connect (syntax: `postgres://DB_USERNAME:DB_PASSWORD@DB_ENDPOINT/DB_NAME`).
    - DB_NAME should be equal to the database that was created inside the cluster either using `CREATE DATABASE ..` command or `db_name` parameter in Terraform for RDS (https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/db_instance#db_name).
    - Do not confuse with DB cluster/instance name, which is what shows up on AWS Console as a name for the database instances.

These two variables need to be set

./api/package.json
Contents of ./api/package.json:
{
  "name": "api",
  "version": "0.0.0",
  "private": true,
  "engines" : { 
    "npm" : ">=8.0.0",
    "node" : ">=16.0.0"
  },
  "scripts": {
    "start": "node ./bin/www"
  },
  "dependencies": {
    "express": "~4.13.1",
    "pg": "8.8.0",
    "node-uuid": "1.4.7"
  }
}

./api/app.js
Contents of ./api/app.js:
var express = require('express');
var app = express();
var uuid = require('node-uuid');

var { Pool } = require('pg');

var conString = process.env.DB; // "postgres://username:password@localhost/database";

// Routes
app.get('/api/status', function (req, res) {
  try {
    const pool = new Pool({
      connectionString: conString,
    });
    pool.query('SELECT now() as time', [], function (err, result) {
      //call `done()` to release the client back to the pool
      if (err) {
        return res.status(500).send('error running query');
      }

      return res.json({
        request_uuid: uuid.v4(),
        time: result.rows[0].time
      });
    });

  } catch (error) {
    console.log('error:')
    console.log(error)
  }
});

// catch 404 and forward to error handler
app.use(function (req, res, next) {
  var err = new Error('Not Found');
  err.status = 404;
  next(err);
});

// error handlers

// development error handler
// will print stacktrace
if (app.get('env') === 'development') {
  app.use(function (err, req, res, next) {
    res.status(err.status || 500);
    res.json({
      message: err.message,
      error: err
    });
  });
}

// production error handler
// no stacktraces leaked to user
app.use(function (err, req, res, next) {
  res.status(err.status || 500);
  res.json({
    message: err.message,
    error: {}
  });
});


module.exports = app;
Contents of .github/workflows/app-pipeline.yaml:

