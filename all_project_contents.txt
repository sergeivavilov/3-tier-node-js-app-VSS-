Directory Structure:
.
├── README.md
├── all_project_contents.txt
├── api
│   ├── Dockerfile
│   ├── README.md
│   ├── app.js
│   ├── bin
│   │   └── www
│   ├── package-lock.json
│   └── package.json
├── compose.yaml
├── helm-chart
│   ├── Chart.yaml
│   ├── templates
│   │   ├── deployment.yaml
│   │   ├── ingress.yaml
│   │   └── service.yaml
│   └── values
│       ├── backend
│       │   └── dev-value.yaml
│       └── frontend
│           └── dev-value.yaml
└── web
    ├── Dockerfile
    ├── README.md
    ├── app.js
    ├── bin
    │   └── www
    ├── package-lock.json
    ├── package.json
    ├── public
    │   └── stylesheets
    │       └── style.css
    ├── routes
    │   └── index.js
    └── views
        ├── error.jade
        ├── index.jade
        └── layout.jade

14 directories, 26 files

./web/README.md
Contents of ./web/README.md:
# Devops Web App

## install the node packages for the web tier

```
npm 8 or higher
node 16 or higher
```


```sh
  npm install
```

## start the app

```sh
  npm start
```

## NOTE this app uses two env variables

- PORT: optional variable to specify the listening PORT. Default is 3000
- API_HOST: the full url to call the API app (syntax: `http://BACKEND_HOSTNAME:BACKEND_PORT`)

These two variables need to be set

## Expected UI page all components are working: Frontend => Backend => DB

![Frontend-expected-UI](https://github.com/312-bc/3-tier-node-js-app-23C/assets/43100287/a1d2dc62-1f34-4c75-8688-77269b4f381e)

./web/public/stylesheets/style.css
Contents of ./web/public/stylesheets/style.css:
body {
  padding: 50px;
  font: 14px "Lucida Grande", Helvetica, Arial, sans-serif;
}

a {
  color: #00B7FF;
}

./web/package.json
Contents of ./web/package.json:
{
  "name": "web",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "start": "node ./bin/www"
  },
  "dependencies": {
    "body-parser": "~1.13.2",
    "cookie-parser": "~1.3.5",
    "debug": "~2.6.9",
    "express": "~4.13.1",
    "jade": "~1.11.0",
    "morgan": "~1.6.1",
    "redis": "^1.0.0",
    "redis-url": "^1.2.1",
    "serve-favicon": "~2.3.0",
    "request": "2.72.0"
  }
}

./web/routes/index.js
Contents of ./web/routes/index.js:
var express = require('express');
var router = express.Router();
var request = require('request');


var api_url = process.env.API_HOST + '/api/status';

/* GET home page. */
router.get('/', function (req, res, next) {
    request({
        method: 'GET',
        url: api_url,
        json: true
    },
        function (error, response, body) {
            if (error || response.statusCode !== 200) {
                return res.status(500).send('error running request to ' + api_url);
            } else {
                res.render('index', {
                    title: 'Frontend - Hi upcoming DevOps Engineers, how is hands-on?',
                    request_uuid: body.request_uuid,
                    time: body.time
                });
            }
        }
    );
});

module.exports = router;
./web/app.js
Contents of ./web/app.js:
var express = require('express');
var path = require('path');
var favicon = require('serve-favicon');
var logger = require('morgan');
var cookieParser = require('cookie-parser');
var bodyParser = require('body-parser');

var routes = require('./routes/index');

var app = express();

// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'jade');

// uncomment after placing your favicon in /public
//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));
app.use(logger('dev'));
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: false }));
app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));

app.use('/', routes);

// catch 404 and forward to error handler
app.use(function(req, res, next) {
  var err = new Error('Not Found');
  err.status = 404;
  next(err);
});

// error handlers

// development error handler
// will print stacktrace
if (app.get('env') === 'development') {
  app.use(function(err, req, res, next) {
    res.status(err.status || 500);
    res.render({
      message: err.message,
      error: err
    });
  });
}

// production error handler
// no stacktraces leaked to user
app.use(function(err, req, res, next) {
  res.status(err.status || 500);
  res.render({
    message: err.message,
    error: {}
  });
});


module.exports = app;

./helm-chart/Chart.yaml
Contents of ./helm-chart/Chart.yaml:
apiVersion: v2
name: nodejs-helm-chart
description: A Helm chart for Kubernetes
type: application

# This is the chart version. This version number should be incremented each time you make changes
version: 0.1.0

# This is the version number of the application being deployed. 
appVersion: "1.16.0"

./helm-chart/values/frontend/dev-value.yaml
Contents of ./helm-chart/values/frontend/dev-value.yaml:
### Deploy
applicationName: nodejs-frontend
replicaCount: 2
image:
  repository: 730335359268.dkr.ecr.us-east-1.amazonaws.com/web-frontend
pullPolicy: ifNotPresent
port: 80

### Service
service:
  type: ClusterIP
  port: 80

### Ingress
ingress:
  create: true
  hostname: vss.click
./helm-chart/values/backend/dev-value.yaml
Contents of ./helm-chart/values/backend/dev-value.yaml:
### Deploy
applicationName: nodejs-backend
replicaCount: 2
image:
  repository: 730335359268.dkr.ecr.us-east-1.amazonaws.com/api-backend
pullPolicy: ifNotPresent
port: 3000

### Service
service:
  type: ClusterIP
  port: 3000

### Ingress
ingress:
  create: false
./helm-chart/templates/deployment.yaml
Contents of ./helm-chart/templates/deployment.yaml:
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Values.applicationName }}
  labels:
    app: {{ .Values.applicationName }}
spec:  
  replicas: {{ .Values.replicaCount }}
  selector:  
    matchLabels:
      app: {{ .Values.applicationName }}
  template:
    metadata:
      labels:
        app: {{ .Values.applicationName }}
    spec:
      containers:
        - name: {{ .Values.applicationName }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - name: http
              containerPort: {{ .Values.port }}
              protocol: TCP
         

./helm-chart/templates/ingress.yaml
Contents of ./helm-chart/templates/ingress.yaml:
{{- if .Values.ingress.create }}
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: "ingress-{{ .Values.applicationName }}"
spec:
  ingressClassName: nginx
  rules:
    - host: {{ .Values.hostname }}
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: "{{ .Values.applicationName }}-svc"
                port:
                  number: {{ .Values.service.port }}
{{- end }}

./helm-chart/templates/service.yaml
Contents of ./helm-chart/templates/service.yaml:
apiVersion: v1
kind: Service
metadata:
  name: "{{ .Values.applicationName }}-svc"
  labels:
    app: {{ .Values.applicationName }}
spec:
  type: {{ .Values.service.type }}
  ports:
    - port: {{ .Values.service.port }}
      targetPort: http
      protocol: TCP
      name: http
  selector:
    app: {{ .Values.applicationName }}

./README.md
Contents of ./README.md:
[![Reviews App CI/CD Pipeline](https://github.com/sergeivavilov/3-tier-node-js-app-vss/actions/workflows/app-pipeline.yaml/badge.svg)](https://github.com/sergeivavilov/3-tier-node-js-app-vss/actions/workflows/app-pipeline.yaml)



[![Reviews App CI/CD Pipeline](https://github.com/sergeivavilov/3-tier-node-js-app-vss/actions/workflows/app-pipeline.yaml/badge.svg)](https://github.com/sergeivavilov/3-tier-node-js-app-vss/actions/workflows/app-pipeline.yaml)



[![Reviews App CI/CD Pipeline](https://github.com/sergeivavilov/3-tier-node-js-app-vss/actions/workflows/app-pipeline.yaml/badge.svg)](https://github.com/sergeivavilov/3-tier-node-js-app-vss/actions/workflows/app-pipeline.yaml)



============================================================================================================================================================== {
  # Print the directory structure
  echo "Directory Structure:"
  tree;
  echo "";

  # Loop through each text-based file including YAML and JSON files and print its contents
  # Exclude package-lock.json to shorten output
  find . -type f \( -name "*.md" -o -name "*.py" -o -name "*.sql" -o -name "*.js" -o -name "*.html" -o -name "*.css" -o -name "*.yaml" -o -name "*.json" \) ! -name "package-lock.json" -print -exec echo "Contents of {}:" \; -exec cat {} \; -exec echo "" \;

  # Explicitly add specific files like the GitHub Actions workflow
  echo "Contents of .github/workflows/kubernetes-deploy.yaml:"
  cat .github/workflows/kubernetes-deploy.yaml
  echo "";
} > all_project_contents.txt



===============================================================================================================================================================





{
  echo "Directory Structure:";
  tree;
  echo "";

  # Loop through each text-based file including YAML and JSON files and print its contents
  find . -type f \( -name "*.md" -o -name "*.py" -o -name "*.sql" -o -name "*.js" -o -name "*.html" -o -name "*.css" -o -name "*.yaml" -o -name "*.json" \) ! -name "package-lock.json" -print -exec echo "Contents of {}:" \; -exec cat {} \; -exec echo "" \;

  # Explicitly add specific files like the GitHub Actions workflow
  echo "Contents of .github/workflows/kubernetes-deploy.yaml:"
  cat 3-tier-node-js-app-vss/.github/workflows/kubernetes-deploy.yaml
  echo "";
} > all_project_contents.txt



================================================================================================================================================================


# 3-Tier Application: Product Review System

## Overview
This repository contains a 3-tier web application, the Product Review System, where users can add products and leave reviews. The 3-tier architecture comprises a frontend, backend, and a database. The application is designed to run on AWS infrastructure with high availability and scalability in mind.

- The Frontend application provides a user interface built with HTML, CSS, and JavaScript, served by an Nginx server. 

- The Backend is a RESTful API built with Python and Flask, which processes requests, performs operations, and interfaces with a MySQL database.

- The MySQL Database stores product and review data.

For more details about each component, refer to the README files in their respective directories:

- [Frontend](./frontend/README.md)
- [Backend](./api-backend/README.md)

## Important Note
Since our frontend just hosts static webpages, it relies on client-side browser processing with Javascript. Therefore requests to the backend come from the user directly (browsers calls the APIs to backend), which means that backend DNS name also needs to be publicly accessible.

Flow of the request is `Client => Frontend => Client => Backend => Database`


## Diagrams

**Software Design Overview**
![Software Design Overview](random/mini-project-software-design.png)

**Infrastructure Design Overview**
![Infrastructure Design Overview](random/mini-project-infra.png)



## Helpful Resources on Learning to work with Git:

Naming Conventions:

- Best practices for file and branch naming: **https://namingconvention.org/git/**

Git/GitHub Fundamentals:

- Official Git documentation: **https://git-scm.com/doc**

Pull Requests (PRs):
- GitHub Pull Request documentation: **https://docs.github.com/en/pull-requests**


./.github/workflows/kubernetes-deploy.yaml
Contents of ./.github/workflows/kubernetes-deploy.yaml:
name: NodeJs Deployment Workflow

on:
  push:
    branches: ["*"]

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ (github.ref == 'refs/heads/main' && 'dev') || (github.ref == 'refs/heads/prod' && 'production') }}

    steps:
      - name: AWS Loggin
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.IAM_ROLE }}
          aws-region: "us-east-1"

      - name: Clone repo
        uses: actions/checkout@v4

      - name: Login to ECR
        id: login-to-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Login to EKS
        run: aws eks update-kubeconfig --region us-east-1 --name project-x-dev

      - name: Create namespace
        run: kubectl create namespace sample-app || true

      - name: Deploy frontend with Helm
        run: |
          helm upgrade --install nodejs-frontend ./helm-chart --values ./helm-chart/values/frontend/dev-value.yaml --namespace sample-app
        env:
          HELM_DEBUG: "true"

      - name: Deploy backend with Helm
        run: |
          helm upgrade --install nodejs-backend ./helm-chart --values ./helm-chart/values/backend/dev-value.yaml --namespace sample-app
        env:
          HELM_DEBUG: "true"

  destroy:
    runs-on: ubuntu-latest

    steps:
      - name: AWS Loggin
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.IAM_ROLE }}
          aws-region: "us-east-1"

      - name: Login to EKS
        run: aws eks update-kubeconfig --region us-east-1 --name project-x-dev

      - name: Destroy frontend deployment
        run: helm uninstall nodejs-frontend --namespace sample-app || true

      - name: Destroy backend deployment
        run: helm uninstall nodejs-backend --namespace sample-app || true

      - name: Delete namespace
        run: kubectl delete namespace sample-app || true

      - name: Logout from ECR
        run: aws ecr logout --region us-east-1

./compose.yaml
Contents of ./compose.yaml:
services:
  webcontainer:
    build: web/
    ports:
      - "80:80"
    networks:
      - appnetwork
    environment:
      API_HOST: "http://apicontainer:3000"
  apicontainer:
    build: api/
    networks:
      - appnetwork
    environment:
      DB: "postgres://pgadmin:crackers@dbcontainer/sampledb"
  dbcontainer:
    image: "postgres:16"
    environment:
      POSTGRES_PASSWORD: "crackers"
      POSTGRES_USER: "pgadmin"
      POSTGRES_DB: "sampledb"
    networks:
      - appnetwork
networks:
  appnetwork:

./api/README.md
Contents of ./api/README.md:
# Devops API App

# System Requirements

```
npm 8 or higher
node 16 or higher
```

## install the node packages for the api tier

```sh
→ npm install
```

## start the app

```sh
→ npm start
```

## NOTE this app uses two env variables

- PORT: optional variable to specify the listening PORT. Default is 3000
- DB: the postgresql url (also called as DB Connection string) to connect (syntax: `postgres://DB_USERNAME:DB_PASSWORD@DB_ENDPOINT/DB_NAME`).
    - DB_NAME should be equal to the database that was created inside the cluster either using `CREATE DATABASE ..` command or `db_name` parameter in Terraform for RDS (https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/db_instance#db_name).
    - Do not confuse with DB cluster/instance name, which is what shows up on AWS Console as a name for the database instances.

These two variables need to be set

./api/package.json
Contents of ./api/package.json:
{
  "name": "api",
  "version": "0.0.0",
  "private": true,
  "engines" : { 
    "npm" : ">=8.0.0",
    "node" : ">=16.0.0"
  },
  "scripts": {
    "start": "node ./bin/www"
  },
  "dependencies": {
    "express": "~4.13.1",
    "pg": "8.8.0",
    "node-uuid": "1.4.7"
  }
}

./api/app.js
Contents of ./api/app.js:
var express = require('express');
var app = express();
var uuid = require('node-uuid');

var { Pool } = require('pg');

var conString = process.env.DB; // "postgres://username:password@localhost/database";

// Routes
app.get('/api/status', function (req, res) {
  try {
    const pool = new Pool({
      connectionString: conString,
    });
    pool.query('SELECT now() as time', [], function (err, result) {
      //call `done()` to release the client back to the pool
      if (err) {
        return res.status(500).send('error running query');
      }

      return res.json({
        request_uuid: uuid.v4(),
        time: result.rows[0].time
      });
    });

  } catch (error) {
    console.log('error:')
    console.log(error)
  }
});

// catch 404 and forward to error handler
app.use(function (req, res, next) {
  var err = new Error('Not Found');
  err.status = 404;
  next(err);
});

// error handlers

// development error handler
// will print stacktrace
if (app.get('env') === 'development') {
  app.use(function (err, req, res, next) {
    res.status(err.status || 500);
    res.json({
      message: err.message,
      error: err
    });
  });
}

// production error handler
// no stacktraces leaked to user
app.use(function (err, req, res, next) {
  res.status(err.status || 500);
  res.json({
    message: err.message,
    error: {}
  });
});


module.exports = app;
Contents of .github/workflows/kubernetes-deploy.yaml:
name: NodeJs Deployment Workflow

on:
  push:
    branches: ["*"]

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ (github.ref == 'refs/heads/main' && 'dev') || (github.ref == 'refs/heads/prod' && 'production') }}

    steps:
      - name: AWS Loggin
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.IAM_ROLE }}
          aws-region: "us-east-1"

      - name: Clone repo
        uses: actions/checkout@v4

      - name: Login to ECR
        id: login-to-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Login to EKS
        run: aws eks update-kubeconfig --region us-east-1 --name project-x-dev

      - name: Create namespace
        run: kubectl create namespace sample-app || true

      - name: Deploy frontend with Helm
        run: |
          helm upgrade --install nodejs-frontend ./helm-chart --values ./helm-chart/values/frontend/dev-value.yaml --namespace sample-app
        env:
          HELM_DEBUG: "true"

      - name: Deploy backend with Helm
        run: |
          helm upgrade --install nodejs-backend ./helm-chart --values ./helm-chart/values/backend/dev-value.yaml --namespace sample-app
        env:
          HELM_DEBUG: "true"

  destroy:
    runs-on: ubuntu-latest

    steps:
      - name: AWS Loggin
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.IAM_ROLE }}
          aws-region: "us-east-1"

      - name: Login to EKS
        run: aws eks update-kubeconfig --region us-east-1 --name project-x-dev

      - name: Destroy frontend deployment
        run: helm uninstall nodejs-frontend --namespace sample-app || true

      - name: Destroy backend deployment
        run: helm uninstall nodejs-backend --namespace sample-app || true

      - name: Delete namespace
        run: kubectl delete namespace sample-app || true

      - name: Logout from ECR
        run: aws ecr logout --region us-east-1

