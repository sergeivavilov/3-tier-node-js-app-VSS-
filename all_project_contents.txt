Directory Structure:
.
├── README.md
├── all_project_contents.txt
├── api-backend
│   ├── Dockerfile
│   ├── README.md
│   ├── app.py
│   └── requirements.txt
├── database
│   └── db-schema-creation.sql
├── frontend
│   ├── Dockerfile
│   ├── README.md
│   ├── app.js
│   ├── index.html
│   └── styles.css
└── random
    ├── load-testing.py
    ├── mini-project-infra.png
    └── mini-project-software-design.png

5 directories, 15 files

./database/db-schema-creation.sql
Contents of ./database/db-schema-creation.sql:
-- Create the products table
CREATE TABLE product (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(80) NOT NULL
);

-- Create the reviews table
CREATE TABLE review (
    id INT PRIMARY KEY AUTO_INCREMENT,
    content VARCHAR(200) NOT NULL,
    product_id INT NOT NULL,
    polarity FLOAT,
    subjectivity FLOAT,
    FOREIGN KEY (product_id) REFERENCES product(id)
);

./frontend/index.html
Contents of ./frontend/index.html:
<!DOCTYPE html>
<html>

<head>
    <title>Review Application</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" crossorigin="anonymous" />
    <link rel="stylesheet" href="styles.css" />
</head>

<body>
    <h1>Review Application</h1>

    <form id="product-form">
        <input type="text" id="product-name" placeholder="Product Name" required>
        <button type="submit">Add Product</button>
    </form>

    <form id="review-form">
        <select id="product-select"></select>
        <input type="text" id="review-content" placeholder="Review" required>
        <button type="submit">Add Review</button>
    </form>

    <div id="reviews"></div>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="app.js"></script>
</body>

</html>

./frontend/styles.css
Contents of ./frontend/styles.css:
/* Star icon styles */

.fa-star {
    color: #dadbdf; /* Grey color for the unfilled star */
}

.fa-star.filled {
    color: #fbbb07; /* Yellow color for the filled star */
}

/* Container style for stars */

.stars-container {
    display: inline-block;
}

./frontend/README.md
Contents of ./frontend/README.md:
# Frontend Application README

## Overview
This is the frontend application for the Review Application, a simple web service that allows users to add and view products and their reviews. The application communicates with the backend application to fetch and display product details and their associated reviews. The frontend application is built using HTML, CSS, and JavaScript, and it's served using Nginx.

## Features
- Users can add new products and provide their names.
- Users can add reviews for existing products.
- Users can view a list of all products and their reviews.
- The application fetches AI-generated sentiment scores (Polarity and Subjectivity) for each review from the backend and displays them along with the review.

## Prerequisites
- Nginx or any other HTTP web server that can serve static files for web hosting.

## Installation
- Install web server package such as `nginx` or `httpd`
- Make sure to replace baseurl value of `'http://reviews-api.exchangeweb.net:80'` in the `app.js` file with the actual DNS name of the backend application.
- Place the html, css, javascript files into a web server directory from which a website is hosted (ex: `/usr/share/nginx/html`)
- Run the web server application (ex: `systemctl start nginx`)
<img width="563" alt="Reviews-App-Frontend-Page" src="https://github.com/312-bc/reviews-app-base/assets/43100287/ea3933f4-6c6e-4b02-8bda-0a2eb0ed826d">


## Troubleshooting
Once you open frontend webpage from browser, it should display options to add products, reviews, and should show reviews once you add them. If these features are not working - check for errors in Chrome Console:

- right click somewhere on the chrome browser page while you have site open => Inspect => Console => errors should show up here (some errors can be ignored, but pay attention to connection errors to backend if you see any)

./frontend/app.js
Contents of ./frontend/app.js:
var baseUrl = 'http://reviews-api.example.com:80'; // Address for the backend/API server

// Add product
$("#product-form").submit(function (e) {
    e.preventDefault();
    var productName = $("#product-name").val();
    $.ajax({
        url: `${baseUrl}/product`,
        type: 'POST',
        data: JSON.stringify({
            product_name: productName
        }),
        contentType: 'application/json; charset=utf-8',
        dataType: 'json',
        success: function (data) {
            alert(data.message);
            loadProducts();
        }
    });
});

// Add review
$("#review-form").submit(function (e) {
    e.preventDefault();
    var productId = $("#product-select").val();
    var reviewContent = $("#review-content").val();
    $.ajax({
        url: `${baseUrl}/product/${productId}/review`,
        type: 'POST',
        data: JSON.stringify({
            review: reviewContent
        }),
        contentType: 'application/json; charset=utf-8',
        dataType: 'json',
        success: function (data) {
            alert(data.message);
            loadReviews(productId);
        }
    });
});

// Load products into dropdown
function loadProducts() {
    $.getJSON(`${baseUrl}/product`, function (data) {
        var dropdown = $("#product-select");
        dropdown.empty();
        $.each(data.products, function () {
            dropdown.append($("<option />").val(this.id).text(this.name));
        });
        dropdown.change();
    });
}

// Load reviews when a product is selected
$("#product-select").change(function () {
    var productId = $(this).val();
    loadReviews(productId);
});

function loadReviews(productId) {
    $.getJSON(`${baseUrl}/product/${productId}/review`, function (data) {
        var reviewsDiv = $("#reviews");
        reviewsDiv.empty();
        $.each(data.reviews, function () {
            var rating = this.rating;
            var stars = $("<span />");
            for (var i = 1; i <= 5; i++) {
                var starIcon = $("<i />").addClass("fas fa-star");
                if (i <= rating) {
                    starIcon.addClass("filled");
                } else {
                    starIcon.addClass("empty");
                }
                stars.append(starIcon);
            }
            var reviewElement = $("<p />").html("<em>" + this.content + "</em>").append(' - AI analyzed rating: ').append(stars);
            reviewsDiv.append(reviewElement);
        });
    });
}

loadProducts();

./README.md
Contents of ./README.md:
# 3-tier-node-js-app-vss
./.github/workflows/app-pipeline.yaml
Contents of ./.github/workflows/app-pipeline.yaml:
name: "Reviews App CI/CD Pipeline"

on:
  push:
    branches:
      - main
      - staging
      - 'feature/**'
  workflow_dispatch:

permissions:
  id-token: write  # Required for OIDC authentication, enabling GitHub Actions to assume an AWS IAM role
  contents: read   # Allows GitHub Actions to check out the code

jobs:
  build-deploy:
    runs-on: ubuntu-latest
    environment: ${{ (github.ref == 'refs/heads/main' && 'production') || (github.ref == 'refs/heads/staging' && 'staging') || 'dev' }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4  # Checks out the repo to $GITHUB_WORKSPACE for the workflow to access

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: githubactionssession
          aws-region: us-east-1

      - name: Check AWS Identity
        run: aws sts get-caller-identity

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Terraform Plan Only
        run: |
          terraform init
          terraform plan




# name: "Reviews App CI/CD Pipeline"

# on:
#   push:
#     branches:
#       - main
#       - staging
#       - 'feature/**'
#   workflow_dispatch:

# permissions:
#   id-token: write  # Required for OIDC authentication, enabling GitHub Actions to assume an AWS IAM role
#   contents: read   # Allows GitHub Actions to check out the code

# jobs:
#   build-deploy:
#     runs-on: ubuntu-latest
#     environment: ${{ (github.ref == 'refs/heads/main' && 'production') || (github.ref == 'refs/heads/staging' && 'staging') || 'dev' }}

#     steps:
#       - name: Checkout Repository
#         uses: actions/checkout@v4  # Checks out the repo to $GITHUB_WORKSPACE for the workflow to access

#       - name: Configure AWS Credentials
#         uses: aws-actions/configure-aws-credentials@v3
#         with:
#           role-to-assume: ${{ secrets.AWS_ROLE_ARN }}  # Correct this to use AWS_ROLE_ARN
#           role-session-name: githubactionssession
#           aws-region: us-east-1

#       - name: Check AWS Identity
#         run: aws sts get-caller-identity



#       # - name: Configure AWS Credentials
#       #   uses: aws-actions/configure-aws-credentials@v3
#       #   with:
#       #     role-to-assume: ${{ secrets.AWS_IAM_ROLE }}
#       #     role-session-name: githubactionssession
#       #     aws-region: us-east-1  # Defines the AWS region for the deployment

#       - name: Login to Amazon ECR
#         id: login-to-ecr
#         uses: aws-actions/amazon-ecr-login@v2  # Authenticates to Amazon ECR to allow subsequent Docker commands

#       - name: Terraform Plan Only
#         run: |
#           # Initialize Terraform
#           terraform init
#           # Output the execution plan but do not apply changes
#           terraform plan
#         # The following steps are commented out to prevent any changes to your AWS infrastructure
#         # - name: Build and Push Docker Images
#         #   env:
#         #     REGISTRY: ${{ steps.login-to-ecr.outputs.registry }}
#         #   run: |
#         #     # Build and push the Backend Docker image
#         #     docker build -t $REGISTRY/reviews-backend:${{ github.sha }} -f Dockerfile.backend .
#         #     docker push $REGISTRY/reviews-backend:${{ github.sha }}
#         #     
#         #     # Build and push the Frontend Docker image
#         #     docker build -t $REGISTRY/reviews-frontend:${{ github.sha }} -f Dockerfile.frontend .
#         #     docker push $REGISTRY/reviews-frontend:${{ github.sha }}
#         #
#         # - name: Deploy to Kubernetes
#         #   run: |
#         #     # Update the Helm charts for both backend and frontend
#         #     helm upgrade --install reviews-backend helm/reviews-backend --namespace default \
#         #       --set image.repository=$REGISTRY/reviews-backend \
#         #       --set image.tag=${{ github.sha }}
#         #     helm upgrade --install reviews-frontend helm/reviews-frontend --namespace default \
#         #       --set image.repository=$REGISTRY/reviews-frontend \
#         #       --set image.tag=${{ github.sha }}

./api-backend/README.md
Contents of ./api-backend/README.md:

# Backend Application README

## Overview

This is the backend application for the Review Application, a simple web service that allows users to add products and reviews. It provides RESTful APIs to manage products and their associated reviews. The application is built using Python and Flask, with a MySQL database to store product and review data.

## Features

- Add new products with their names.
- Add reviews for existing products, along with sentiment analysis for each review.
- Retrieve a list of all products and their reviews.

### AI Features

The backend application leverages AI-driven sentiment analysis using the TextBlob library to enhance the review system. When users submit reviews, the application automatically performs sentiment analysis on the review content, providing additional insights into each review's sentiment. The sentiment analysis generates two scores for each review:

- **Polarity**: A numeric value indicating the sentiment's polarity ranging from -1.0 (negative) to 1.0 (positive).
- **Subjectivity**: A numeric value indicating the review's subjectivity ranging from 0.0 (objective) to 1.0 (subjective).

These AI-generated scores enable users to gain a better understanding of the sentiment expressed in reviews, and they can also be used to visualize and analyze product sentiment over time.


## Prerequisites

- Python 3.6 or higher
- MySQL database (with appropriate credentials and schema) or use AWS SecretsManager for database credentials.

## Installation

1. Clone the repository:

```sh
git clone ssh_clone_url_for_the_repo
cd api-backend/
```

2. Install the required packages:

```sh
pip install -r requirements.txt
```

## Configuration

1. Database Credentials:

   The application retrieves database credentials from AWS SecretsManager. Secret name should match what the application expects(`db_credentials = get_secret('your_secret_name_here')` line the `app.py` file). Make sure to create a secret in AWS SecretsManager containing the required database credentials in the form of a dictionary, as shown below:

   ```json
   {
       "DB_USERNAME": "your_db_username",
       "DB_PASSWORD": "your_db_password",
       "DB_ENDPOINT": "your_db_endpoint",
       "DB_NAME": "your_db_name"
   }

2. Running the Application:

    To start the Flask server, run the following command:

    ```sh
    python app.py
    ```

    The application will be accessible at port 80 by default.

# API Endpoints

- **POST /product:** Add a new product.

    Request:

    ```bash
    curl -X POST -H "Content-Type: application/json" -d '{"product_name": "Product Name"}' http://localhost:80/product
    ```
    Response:

    ```json
    {
        "message": "Product added successfully",
        "product_id": 1
    }
    ```

- **POST /product/{product_id}/review:** Add a review for a product.

    Request:

    ```bash
    curl -X POST -H "Content-Type: application/json" -d '{"review": "Review content"}' http://localhost:80/product/{product_id}/review
    ```
    Response:

    ```json
    {
        "message": "Review added successfully",
        "review_id": 1,
        "polarity": 0.5,
        "subjectivity": 0.6
    }
    ```

    Replace {product_id} with the actual ID of the product you want to add the review for.


- **GET /product:** Get a list of all products.

    Request:

    ```bash
    curl -X GET http://localhost:80/product
    ```
    Response:

    ```json
    {
        "products": [
            {
                "id": 1,
                "name": "Product Name 1"
            },
            {
                "id": 2,
                "name": "Product Name 2"
            }
        ]
    }
    ```

- **GET /product/{product_id}/review:** Get reviews for a specific product.

    Request:

    ```bash
    curl -X GET http://localhost:80/product/{product_id}/review
    ```
    Response:

    ```json
    {
        "reviews": [
            {
                "id": 1,
                "content": "Review content 1",
                "rating": 8,
                "subjectivity": 0.6
            },
            {
                "id": 2,
                "content": "Review content 2",
                "rating": 7,
                "subjectivity": 0.7
            }
        ]
    }
    ```

# Health check Endpoints/HTTP path

- When configuring Health checks (ex: on an Application Load Balancer) to check if this backend application is healthy - you can use `/product` HTTP path above as it will return an HTTP 200 status code if the application is healthy and can display a list of available products in the database.


./api-backend/app.py
Contents of ./api-backend/app.py:
import os
import boto3
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
from textblob import TextBlob

app = Flask(__name__)
CORS(app)

# Retrieve database credentials from AWS SecretsManager (comment out the L12:L20 if you are using ENV VARS to retrieve DB credentials)
def get_secret(secret_name, region_name="us-east-1"):
    client = boto3.client('secretsmanager', region_name=region_name)
    response = client.get_secret_value(SecretId=secret_name)
    secret_data = response['SecretString']
    return eval(secret_data)  # Assuming the secret data is stored as a dictionary

# Database credentials retrieved from AWS SecretsManager
db_credentials = get_secret('your_secret_name_here')
app.config['SQLALCHEMY_DATABASE_URI'] = f"mysql+pymysql://{db_credentials['DB_USERNAME']}:{db_credentials['DB_PASSWORD']}@{db_credentials['DB_ENDPOINT']}/{db_credentials['DB_NAME']}"

# Setup with ENV variables (comment out L23 if you are using AWS SecretsManager to retrieve DB credentials)
# app.config['SQLALCHEMY_DATABASE_URI'] = f"mysql+pymysql://{os.environ.get('DB_USERNAME')}:{os.environ.get('DB_PASSWORD')}@{os.environ.get('DB_ENDPOINT')}/{os.environ.get('DB_NAME')}"

app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)

class Product(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), unique=True, nullable=False)
    reviews = db.relationship('Review', backref='product', lazy=True)

class Review(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.String(200), nullable=False)
    product_id = db.Column(db.Integer, db.ForeignKey('product.id'), nullable=False)
    polarity = db.Column(db.Float)    # added field for sentiment polarity
    subjectivity = db.Column(db.Float)  # added field for sentiment subjectivity

@app.route('/product', methods=['POST'])
def add_product():
    product_name = request.json.get('product_name')
    product = Product(name=product_name)
    db.session.add(product)
    db.session.commit()
    return jsonify({'message': 'Product added successfully', 'product_id': product.id})

@app.route('/product/<int:product_id>/review', methods=['POST'])
def add_review(product_id):
    review_content = request.json.get('review')

    # Add sentiment analysis
    sentiment = TextBlob(review_content).sentiment
    polarity = sentiment.polarity
    subjectivity = sentiment.subjectivity

    review = Review(content=review_content, product_id=product_id, polarity=polarity, subjectivity=subjectivity)
    db.session.add(review)
    db.session.commit()
    return jsonify({'message': 'Review added successfully', 'review_id': review.id, 'polarity': polarity, 'subjectivity': subjectivity})

@app.route('/product', methods=['GET'])
def get_products():
    products = Product.query.all()
    return jsonify({'products': [{'id': product.id, 'name': product.name} for product in products]})

@app.route('/product/<int:product_id>/review', methods=['GET'])
def get_reviews(product_id):
    reviews = Review.query.filter_by(product_id=product_id).all()
    def convert_to_star_rating(polarity):
        # Map polarity score to a scale of 1 to 10
        star_rating = round(((polarity + 1.0) / 2.0) * 10)
        return star_rating
    return jsonify({'reviews': [
        {
            'id': review.id,
            'content': review.content,
            'rating': convert_to_star_rating(review.polarity),
            'subjectivity': review.subjectivity
        } for review in reviews
    ]})

if __name__ == "__main__":
    app.run(debug=True, host='0.0.0.0', port=80)

./random/load-testing.py
Contents of ./random/load-testing.py:
import requests
import random
import string

BASE_URL = 'http://reviews-api.example.com:80'  # Replace with your backend URL

# Generate random reviews
def generate_reviews(num_reviews):
    reviews = []
    for _ in range(num_reviews):
        review_content = ''.join(random.choices(string.ascii_letters + string.digits, k=100))
        reviews.append({'review': review_content})
    return reviews

# Submit reviews to the system
def submit_reviews(reviews):
    url = f"{BASE_URL}/product/1/review"  # Replace '1' with the appropriate product ID
    for review in reviews:
        response = requests.post(url, json=review)
        if response.status_code == 200:
            print("Review added successfully")
        else:
            print("Failed to add review")

# Generate and submit reviews
num_reviews = 20000  # Number of reviews to generate and submit
reviews = generate_reviews(num_reviews)
submit_reviews(reviews)

